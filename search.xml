<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Skip_list]]></title>
    <url>%2F2018%2F12%2F25%2FSkip-list%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;Because the binary search depends on the characteristics of array random access, it can only be implemented with arrays. If the data is stored in a linked list, is it really impossible to use the binary search algorithm? &nbsp;&nbsp;&nbsp;&nbsp;In fact, we only need to modify the linked list to support a search algorithm similar to &quot;binary search&quot;. We call the data structure after the transformation “Skip list”(跳表). &nbsp;&nbsp;&nbsp;&nbsp;It is a dynamic data structure with excellent performance in all aspects. It can support fast insertion, deletion, and search operations. It is not complicated to write, and can even replace Red-black trees. How to understand Skip list&nbsp;&nbsp;&nbsp;&nbsp;For a single linked list, even if the data stored in the linked list is ordered, if we want to find a certain data in it, we can only traverse the linked list from beginning to end. This way the search efficiency will be very low, the time complexity will be very high, it is O(n). &nbsp;&nbsp;&nbsp;&nbsp;The two nodes extract a node to the upper level, and we refer to the extracted level as the index or index layer. The down in the figure represents the down pointer, pointing to the next level node. &nbsp;&nbsp;&nbsp;&nbsp;If we are looking for a node now, say 16 . We can traverse the index layer first. When traversing to the node with a value of 13 in the index layer, we find that the next node is 17, and the node 16 to be found must be between the two nodes. Then we descend to the original linked list layer by the down pointer of the index layer node and continue traversing. At this time, we only need to traverse 2 nodes, we can find the node with the value equal to 16. Thus, if you want to find 16 and need to traverse 10 nodes, you only need to traverse 7 nodes. &nbsp;&nbsp;&nbsp;&nbsp;From this example, we can see that after adding a layer of index, the number of nodes that need to traverse a node is reduced, which means that the search efficiency is improved. Then what if we add another level of index? Will efficiency increase more? &nbsp;&nbsp;&nbsp;&nbsp;Similar to the way the first level index is built before, we base the first level index on the two nodes and extract a node to the second level index. Now let’s look up 16 again, we only need to traverse 6 nodes, and the number of nodes that need to be traversed is reduced. &nbsp;&nbsp;&nbsp;&nbsp;The above example does not have a large amount of data, so even if a two-level index is added, the improvement in search efficiency is not obvious. The following figure is a linked list of 64 nodes. According to the above idea, a five-level index is established. &nbsp;&nbsp;&nbsp;&nbsp;As can be seen from the figure, when there is no index, the search 62 needs to traverse 62 nodes. Now only need to traverse 11 nodes, the speed is much improved! Therefore, when the length n of the linked list is relatively large, such as 1000 and 10000, the efficiency of the search will be very obvious after the index is built. How fast is the query with Skip list?&nbsp;&nbsp;&nbsp;&nbsp;The execution efficiency of the algorithm can be measured by time complexity, which is still available here. We know that the time complexity of querying a data in a single linked list is O(0). So in a jump table with a multi-level index, what is the time complexity of querying a certain data? &nbsp;&nbsp;&nbsp;&nbsp;Let’s look at such a question. If there are n nodes in the list, how many levels of index will there be? &nbsp;&nbsp;&nbsp;&nbsp;According to the above, the number of nodes in the first level index is about n/2, the number of nodes in the second level index is about n/4, and the number of nodes in the third level index is about n/8. By analogy, that is, the number of nodes of the k-th index is 1/2 of the number of nodes of the k-1th index, and the number of the k-th index nodes is n / (2^k). &nbsp;&nbsp;&nbsp;&nbsp;Suppose the index has h levels, and the most advanced index has 2 nodes. By the above formula, n/(2^h)=2 can be obtained, thereby obtaining h=log2(n-1). If the original linked list layer is included, the height of the entire jump table is log2n. When we query a certain data in the jump table, if each layer has to traverse m nodes, the time complexity of querying a data in the jump table is O(m * logn). &nbsp;&nbsp;&nbsp;&nbsp;What is the value of this m? According to the previous index structure, each level of our index only needs to traverse up to 3 nodes, that is, m = 3. &nbsp;&nbsp;&nbsp;&nbsp;Suppose the data we are looking for is x. In the k-th index, after we traverse to the y node, we find that x is greater than y and less than the subsequent z, so we drop from the k-th index through the down pointer of y. Go to the k-1 level index. In the k-1th index, there are only 3 nodes (including y and z) between y and z. Therefore, we only need to traverse 3 nodes in the k-1 level index, and so on, each level index only needs to traverse 3 nodes at most. &nbsp;&nbsp;&nbsp;&nbsp;Through the above analysis, we get m = 3. So the time complexity of querying arbitrary data in the jump table is O(logn). The time complexity of this lookup is the same as the binary search. In other words, we actually implemented a binary search based on a single-linked list. However, the efficiency of this query is improved, provided that many levels of indexing are established. Is the Skip list a waste of memory?&nbsp;&nbsp;&nbsp;&nbsp;Compared to the faded single-linked list, the jump table needs to store multiple levels of index, which definitely consumes more storage space. How much extra storage does it take in the end? &nbsp;&nbsp;&nbsp;&nbsp;The spatial complexity analysis of the jump table is not difficult. Assuming that the original linked list size is n, the first level index has about n/2 nodes, the second level index has about n/4 nodes, and so on. When you increase the level, you cut it by half until you have 2 nodes left. If we write the number of nodes in each layer of the index, it is an equal series. &nbsp;&nbsp;&nbsp;&nbsp;The sum of the nodes of these levels of index is n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2. Therefore, the space complexity of the jump table is O(n). That is to say, if a single-linked list containing n nodes is constructed as a jump table, we need to additionally use storage space close to n nodes. &nbsp;&nbsp;&nbsp;&nbsp;If we have three or five nodes, draw a node to the superior index. Although the space complexity is still O(n), the index construction method of the two nodes above is to reduce the storage space of the index node by half. Efficient dynamic insertion and deletion&nbsp;&nbsp;&nbsp;&nbsp;We know that in a single-linked list, once the position to be inserted is located, the time complexity of inserting the node is very low. It is O(1). However, in order to ensure the order of the data in the original linked list, we need to find the location to be inserted first, this search operation will be more time consuming. &nbsp;&nbsp;&nbsp;&nbsp;For a purely singly linked list, you need to iterate through each node to find the location of the insertion. However, for the jump table, we have said that the time complexity of finding a node is O(logn), so here is to find the location where a certain data should be inserted. The method is similar, and the time complexity is also O(logn). &nbsp;&nbsp;&nbsp;&nbsp;If this node also appears in the index, in addition to deleting the nodes in the original linked list, we also delete the nodes in the index. Because the delete operation in the singly linked list needs to get the predecessor node of the deleted node, then the deletion is completed by the pointer operation. So when looking for the node to delete, be sure to get the precursor node. Of course, if we use a doubly linked list, we don’t need to consider this issue. Skip list index update&nbsp;&nbsp;&nbsp;&nbsp;When we keep inserting data into the Skip list, if we don’t update the index, there may be a lot of data between the two index nodes. In extreme cases, Skip list will also degenerate into a singly linked list.&nbsp;&nbsp;&nbsp;&nbsp;As a dynamic data structure, we need some means to maintain the balance between the index and the original linked list size. That is to say, if there are more nodes in the linked list, the index nodes will be increased accordingly, avoiding complexity degradation, and performance degradation of lookup, insertion, and deletion operations. &nbsp;&nbsp;&nbsp;&nbsp;If you understand the balanced binary tree like red black tree and AVL tree, you know that they maintain the balance of the size of the left and right subtrees by rotating left and right, and Skip list maintains the aforementioned “balance” through random functions. &nbsp;&nbsp;&nbsp;&nbsp;When we insert data into the Skip list, we can choose to insert this data into the partial index layer at the same time. How to choose which index layer to join? &nbsp;&nbsp;&nbsp;&nbsp;We use a random function to determine which level of index to insert this node into. If the random function generates the value k, then we will add this node to the k-level index from the first level to the kth level. &nbsp;&nbsp;&nbsp;&nbsp;The choice of random function is very particular. From the probabilistic point of view, the index size and data size balance of Skip list can be guaranteed, and the performance is not degraded excessively. Java code for Skip list123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class SkipList &#123; private static final int MAX_LEVEL = 16; private int levelCount = 1; private Node head = new Node(); // 带头链表 private Random r = new Random(); public Node find(int value) &#123; Node p = head; for (int i = levelCount - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; p.forwards[i].data &lt; value) &#123; p = p.forwards[i]; &#125; &#125; if (p.forwards[0] != null &amp;&amp; p.forwards[0].data == value) &#123; return p.forwards[0]; &#125; else &#123; return null; &#125; &#125; public void insert(int value) &#123; int level = randomLevel(); Node newNode = new Node(); newNode.data = value; newNode.maxLevel = level; Node update[] = new Node[level]; for (int i = 0; i &lt; level; ++i) &#123; update[i] = head; &#125; // record every level largest value which smaller than insert value in update[] Node p = head; for (int i = level - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; p.forwards[i].data &lt; value) &#123; p = p.forwards[i]; &#125; update[i] = p;// use update save node in search path &#125; // in search path node next node become new node forwords(next) for (int i = 0; i &lt; level; ++i) &#123; newNode.forwards[i] = update[i].forwards[i]; update[i].forwards[i] = newNode; &#125; // update node hight if (levelCount &lt; level) levelCount = level; &#125; public void delete(int value) &#123; Node[] update = new Node[levelCount]; Node p = head; for (int i = levelCount - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; p.forwards[i].data &lt; value) &#123; p = p.forwards[i]; &#125; update[i] = p; &#125; if (p.forwards[0] != null &amp;&amp; p.forwards[0].data == value) &#123; for (int i = levelCount - 1; i &gt;= 0; --i) &#123; if (update[i].forwards[i] != null &amp;&amp; update[i].forwards[i].data == value) &#123; update[i].forwards[i] = update[i].forwards[i].forwards[i]; &#125; &#125; &#125; &#125; // 随机 level 次，如果是奇数层数 +1，防止伪随机 private int randomLevel() &#123; int level = 1; for (int i = 1; i &lt; MAX_LEVEL; ++i) &#123; if (r.nextInt() % 2 == 1) &#123; level++; &#125; &#125; return level; &#125; public void printAll() &#123; Node p = head; while (p.forwards[0] != null) &#123; System.out.print(p.forwards[0] + " "); p = p.forwards[0]; &#125; System.out.println(); &#125; public class Node &#123; private int data = -1; private Node forwards[] = new Node[MAX_LEVEL]; private int maxLevel = 0; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(); builder.append("&#123; data: "); builder.append(data); builder.append("; levels: "); builder.append(maxLevel); builder.append(" &#125;"); return builder.toString(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析第一个Android程序]]></title>
    <url>%2F2018%2F12%2F23%2F%E5%88%86%E6%9E%90%E7%AC%AC%E4%B8%80%E4%B8%AAAndroid%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;There is no description of the installation, configuration, and operation of Android Studio. If you need it, please visit Baidu or Google. I will directly analyze the project structure of Android, taking the default project as an example. &nbsp;&nbsp;&nbsp;&nbsp;Go back to Android Studio, first expand the HellpoWorld project, you will see the project structure shown below. &nbsp;&nbsp;&nbsp;&nbsp;Any new project will default to the Android project structure, but this is not the actual directory structure of the project, but was converted by Android Studio. The project is simple and straightforward, suitable for rapid development, but may not be easy for newcomers like me. Click the Android area in the figure to convert the project structure mode. &nbsp;&nbsp;&nbsp;&nbsp;Here we switch the project structure mode to project, which is the real directory structure of the project. Outer directory.gradle and .idea&nbsp;&nbsp;&nbsp;&nbsp;These two directories contain some files automatically generated by Android Studio. We don’t need to care, and don’t edit them manually. app&nbsp;&nbsp;&nbsp;&nbsp;The code, resources, and other content in the project are stored almost entirely in this directory, and our next development work is basically performed in this directory. build&nbsp;&nbsp;&nbsp;&nbsp;This directory does not need to be too concerned, it mainly contains some files that are automatically generated at compile time. gradle&nbsp;&nbsp;&nbsp;&nbsp;This directory contains the gradle wrapper configuration file. The gradle wrapper method does not need to download the gradle in advance, but will automatically decide whether to download the gradle based on the local cache. Android Studio does not have the gradle wrapper method enabled by default. If you need to open it, you can click the Android Studio navigation bar -&gt; File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Gradle to configure the replacement. .gitignore&nbsp;&nbsp;&nbsp;&nbsp;This file is used to exclude specified directories or files from version control. build.gradle&nbsp;&nbsp;&nbsp;&nbsp;This is the project’s global gradle build script, usually the contents of this file do not need to be modified. gradle.properties&nbsp;&nbsp;&nbsp;&nbsp;This file is a global gradle configuration file, and the properties configured here will affect all gradle compilation scripts in the project. gradlew and gradlew.bat&nbsp;&nbsp;&nbsp;&nbsp;These two files are used to execute the gradle command in the command line interface, where gradlew is used on Linux or Mac systems, and gradlew.bat is used on Windows systems. HelloWorld.iml&nbsp;&nbsp;&nbsp;&nbsp;The iml file is a file that is automatically generated by all InteliJ IDEA projects (Android Studio is based on IntelliJ IDEA), which is used to identify this is an IntelliJ IDEA project, we do not need to modify anything in this file. local.properties&nbsp;&nbsp;&nbsp;&nbsp;This file is used to specify the Android SDK path in this machine. Usually the content is automatically generated, we do not need to modify it. Unless the location of the Android SDK in your machine changes, change the path in this file to a new location. settings.gradle&nbsp;&nbsp;&nbsp;&nbsp;This file is used to specify all imported modules in the project. Since the HelloWorld project has only one app module, only the app module is introduced in the file. Usually, the introduction of modules is done automatically, and the scenes that require us to manually modify this file may be less.&nbsp;&nbsp;&nbsp;&nbsp;The outer directory structure of the entire project is now complete. You will find that most files and directories are automatically generated in addition to the app directory, and we don’t need to modify them. App directory build&nbsp;&nbsp;&nbsp;&nbsp;This directory is similar to the outer build directory, and mainly contains some files that are automatically generated at compile time. However, the content inside it will be more complicated, we don’t need too much care. libs&nbsp;&nbsp;&nbsp;&nbsp;If you use a third-party jar package in your project, you need to put these jars in the libs directory. The jars placed in this directory will be automatically added to the build path. androidTest&nbsp;&nbsp;&nbsp;&nbsp;This is used to write Android Test test cases, you can do some automated testing of the project. java&nbsp;&nbsp;&nbsp;&nbsp;There is no doubt that the java directory is where all our Java code is stored. Expand the directory and you will see the HelloWorldActivity file we just created. res&nbsp;&nbsp;&nbsp;&nbsp;There is a lot of content in this directory. To put it simply, all the images, layouts, strings, and other resources that you use in your project should be stored in this directory. Of course, there are many subdirectories under this directory. The images are placed in the drawable directory, the layout is placed in the layout directory, and the strings are placed in the values directory. AndroidManifest.xml&nbsp;&nbsp;&nbsp;&nbsp;This is the configuration file for your entire Android project. All four components you define in the program need to be registered in this file. You can also add a permission declaration to the application in this file. test&nbsp;&nbsp;&nbsp;&nbsp;Here is another way to write a Unit Test test case for automated testing of a project. .gitignore&nbsp;&nbsp;&nbsp;&nbsp;This file is used to exclude specified directories or files within the app module from version control, similar to the outer .gitignore file. app.iml&nbsp;&nbsp;&nbsp;&nbsp;The files generated automatically by the IntelliJ IDEA project, we do not need to care about or modify the contents of this file. build.gradle&nbsp;&nbsp;&nbsp;&nbsp;This is the gradle build script for the app module, which specifies a number of project build related configurations. proguard-rules.pro&nbsp;&nbsp;&nbsp;&nbsp;This file is used to specify the obfuscation rules of the project code. When the code is developed, it is marked as an installation package file. If you do not want the code to be cracked by others, the code will usually be confused, making it difficult for the cracker to read. &nbsp;&nbsp;&nbsp;&nbsp;So the directory structure of the entire project is finished. Analyze project operation&nbsp;&nbsp;&nbsp;&nbsp;Next, analyze how the HelloWorld project works.&nbsp;&nbsp;&nbsp;&nbsp;First open the Android_Manifest.xml file, you can find the following code: &nbsp;&nbsp;&nbsp;&nbsp;This code indicates that the HelloWorldActivity activity is registered, and activities that are not registered in AndroidManifest.xml are not available. The two lines of code in the intent-filter are very important, indicating that HelloWorldActivity is the main activity of the project. Click on the application icon on the phone, the first activity is started. &nbsp;&nbsp;&nbsp;&nbsp;Activities are the facade of the Android app, and everything you see in the app is in the activity. Therefore, the interface seen in the figure below is actually the activity of HelloWorldActivity. &nbsp;&nbsp;&nbsp;&nbsp;Take a look at its code and open HelloWorldActivity.java with the code as shown below. &nbsp;&nbsp;&nbsp;&nbsp;First of all, we can see that HelloWorldActivity is inherited from AppCompatActivity, which is a backward compatible Activity, which can be compatible with Android 2.1 system with the added features and functions of Activity in each system version. Activity is an activity base class provided by the Android system. All activities in our project must inherit it or its subclasses to have the characteristics of the activity (AppCompatActivity is a subclass of Activity). Then you can see that there is an onCreate() method in HelloWorldActivity. This method is a method that must be executed when an activity is created. There are only two lines of code and there is no Hello World!. So where is Hello World! defined? &nbsp;&nbsp;&nbsp;&nbsp;In fact, the design of the Android program is about logic and view separation. Therefore, it is not recommended to write the interface directly in the activity. A more general approach is to write the interface in the layout file and then introduce it in the activity. As you can see, the setContenView() method is called on the second line of the onCreate() method. This method introduces a hello_world_layout layout for the current activity, and Hello World! must be defined here! &nbsp;&nbsp;&nbsp;&nbsp;The layout files are all defined in the res/layout directory. When you expand the layout directory, you will see the hello_world_layout.xml file. Open the file and switch to the Text view, the code is as follows: &nbsp;&nbsp;&nbsp;&nbsp;So we have analyzed the directory structure of the HelloWorld project and the basic execution process. Explain the resources in the project&nbsp;&nbsp;&nbsp;&nbsp;If you look at the res directory, there are still quite a lot of things inside, so it’s easy to see people dazzled. &nbsp;&nbsp;&nbsp;&nbsp;All folders starting with drawable are used to put images. All folders starting with mipmap are used to put application icons. All folders starting with values are used to put strings, colors, styles, etc. Configured, the layout folder is used to put layout files. &nbsp;&nbsp;&nbsp;&nbsp;The reason why there are so many folders starting with minmap is actually to make the program more compatible with various devices. The same is true for the rawable folder. &nbsp;&nbsp;&nbsp;&nbsp;Know the meaning of each folder in the res directory, let’s see how to use these resources. Open the res/values/strings.xml file: &nbsp;&nbsp;&nbsp;&nbsp;As you can see, here is a string that defines an application name. We have two ways to reference it. A reference to the string can be obtained from the code via R.string.app_name. A reference to the string can be obtained in @xml/app_name in XML &nbsp;&nbsp;&nbsp;&nbsp;The basic syntax is the above two ways, where the string part is replaceable. Here’s a simple example to help understand, open the AndroidManifest.xml file and find the following code:123456789&lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; ...&lt;/application&gt; &nbsp;&nbsp;&nbsp;&nbsp;Among them, the application icon of the HelloWorld project is specified by the android:icon attribute, and the name of the application is specified by the android:label attribute. As you can see, the way resources are referenced here is exactly what we just learned to reference resources in XML.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
